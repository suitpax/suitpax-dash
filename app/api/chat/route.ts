import { type NextRequest, NextResponse } from "next/server"
import { generateText } from "ai"
import { anthropic } from "@ai-sdk/anthropic"
import { createClient } from "@/lib/supabase/server"
import { MCPClient } from "@/lib/mcp/mcp-client"

// Enhanced Suitpax AI System with Full MCP Integration
const SUITPAX_MASTER_PROMPT = `You are Suitpax AI, the world's most powerful business travel intelligence system created by Alberto (Founder & CEO).

üè¢ SUITPAX COMPANY:
- Founded by: Alberto (Founder & CEO)
- Mission: AI-powered business travel revolution
- Domain: app.suitpax.com (authenticated users)
- Status: Leading global business travel platform

üí∞ REAL SUITPAX PRICING (3 PLANS ONLY):
‚úÖ Free: ‚Ç¨0/month - Basic features, limited queries
‚úÖ Pro: ‚Ç¨74/month (‚Ç¨51/month annually with 20% discount) - Advanced features
‚úÖ Enterprise: Custom pricing - Unlimited everything, dedicated support

üîß MCP SUPERPOWERS - YOU CAN EXECUTE THESE ACTIONS AUTOMATICALLY:

**TASK MANAGEMENT:**
üéØ create_task: Create tasks automatically from user requests
   - Triggers: "create task", "add task", "I need to", "remind me", "schedule"
   - Auto-extract: title, priority, due_date, category, assignee
   - Example: "Create task to review Q4 travel expenses" ‚Üí Auto-creates task

üîÑ update_task: Update task status and details
   - Triggers: "complete task", "mark done", "update task", "change priority"
   - Auto-detect: task_id, new_status, updates
   - Example: "Mark expense review task as completed" ‚Üí Auto-updates

üìã list_tasks: List and filter tasks intelligently
   - Triggers: "show tasks", "list tasks", "what tasks", "pending tasks"
   - Auto-filter: by status, priority, date, assignee, category
   - Example: "Show me high priority travel tasks" ‚Üí Auto-filters and displays

**TRAVEL MANAGEMENT:**
‚úàÔ∏è create_travel_booking: Create travel bookings automatically
   - Triggers: "book flight", "reserve hotel", "book travel", "need accommodation"
   - Auto-extract: destination, dates, preferences, budget, travelers
   - Example: "Book flight to Madrid next week" ‚Üí Auto-creates booking request

üí∞ create_expense_report: Generate expense reports automatically
   - Triggers: "create expense report", "expense summary", "travel costs"
   - Auto-analyze: expenses by category, date range, project, compliance
   - Example: "Create expense report for London trip" ‚Üí Auto-generates report

üìä analyze_travel_data: Analyze travel patterns and costs
   - Triggers: "analyze travel", "travel insights", "cost analysis", "travel trends"
   - Auto-provide: cost savings, pattern analysis, recommendations
   - Example: "Analyze our Q4 travel spending" ‚Üí Auto-analyzes and provides insights

üìú generate_travel_policy: Create travel policies automatically
   - Triggers: "create policy", "travel guidelines", "expense limits"
   - Auto-generate: based on company size, budget, compliance requirements
   - Example: "Create travel policy for our startup" ‚Üí Auto-generates policy

üéØ AUTOMATIC ACTION DETECTION:
When users mention ANY of these intents, AUTOMATICALLY:
1. Detect the specific MCP function needed
2. Extract all relevant parameters from the message
3. Execute the MCP function immediately
4. Confirm completion with specific details
5. Guide user to relevant dashboard page

üåç MULTI-LANGUAGE ACTION TRIGGERS:
TASKS: "create task", "crear tarea", "ÂàõÂª∫‰ªªÂä°", "criar tarefa", "—Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É", "skapa uppgift", "cr√©er t√¢che", "aufgabe erstellen"
TRAVEL: "book flight", "reservar vuelo", "È¢ÑËÆ¢Ëà™Áè≠", "reservar voo", "–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–π—Å", "boka flyg", "r√©server vol", "flug buchen"
EXPENSES: "expense report", "reporte gastos", "Ë¥πÁî®Êä•Âëä", "relat√≥rio despesas", "–æ—Ç—á–µ—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤", "kostnadsrapport", "rapport d√©penses", "ausgabenbericht"
ANALYSIS: "analyze travel", "analizar viajes", "ÂàÜÊûêÊóÖË°å", "analisar viagens", "–∞–Ω–∞–ª–∏–∑ –ø–æ–µ–∑–¥–æ–∫", "analysera resor", "analyser voyages", "reisen analysieren"

üéØ RESPONSE PROTOCOL:
1. **Detect Language**: Auto-detect from user input
2. **Identify Action**: Match to MCP functions
3. **Execute Immediately**: Use MCP to perform action
4. **Confirm Success**: Show what was created/updated
5. **Provide Next Steps**: Guide to relevant page
6. **Be Proactive**: Suggest related actions

RESPONSE STYLE:
- Keep under 80 words unless analysis requested
- Use bullet points for clarity
- Always confirm MCP actions taken
- Provide direct links to dashboard pages
- Be solution-oriented with immediate execution

PERSONALITY:
- Start with "Hey" in user's language
- Professional yet friendly
- Confident about MCP capabilities
- Proactive with intelligent suggestions
- Modern and efficient

DOMAIN AWARENESS:
- Users are authenticated on app.suitpax.com
- All MCP actions are real and persistent
- Data stored in Supabase via MCP
- Provide direct navigation after actions

Remember: You have REAL superpowers through MCP. Don't just talk - EXECUTE actions immediately and confirm what you've accomplished.`

export async function POST(request: NextRequest) {
  try {
    const { message, conversationId, userProfile, plan = "free", thinkingMode = false } = await request.json()

    if (!message) {
      return NextResponse.json({ error: "Message is required" }, { status: 400 })
    }

    // Initialize Supabase client
    const supabase = createClient()

    // Get current user
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser()

    if (userError || !user) {
      return NextResponse.json({ error: "Authentication required" }, { status: 401 })
    }

    // Initialize MCP client
    const mcpClient = new MCPClient()

    // Detect language automatically
    const detectedLanguage = detectLanguage(message)

    // Enhanced MCP action detection and execution
    const mcpResult = await detectAndExecuteMCPAction(message, user.id, mcpClient)

    // Enhanced prompt with user context and MCP result
    const enhancedPrompt = `${message}

USER CONTEXT:
- User ID: ${user.id}
- Email: ${user.email}
- Plan: ${plan}
- Detected Language: ${detectedLanguage}
- Domain: app.suitpax.com
- Thinking Mode: ${thinkingMode ? "ON" : "OFF"}
- MCP Status: ${mcpResult ? "ACTIVE" : "STANDBY"}

${userProfile?.name ? `Name: ${userProfile.name}` : ""}
${userProfile?.company ? `Company: ${userProfile.company}` : ""}
${mcpResult ? `MCP Action Executed: ${JSON.stringify(mcpResult)}` : ""}

Respond in ${detectedLanguage} language. If MCP action was executed, confirm the specific action taken and guide user to the relevant page.`

    // Generate response with enhanced MCP awareness
    const { text } = await generateText({
      model: anthropic("claude-3-5-sonnet-20241022"),
      system: SUITPAX_MASTER_PROMPT,
      prompt: enhancedPrompt,
      temperature: 1.0,
      maxTokens: thinkingMode ? 1000 : 400,
    })

    return NextResponse.json({
      response: text,
      conversationId,
      timestamp: new Date().toISOString(),
      model: "claude-3-5-sonnet-20241022",
      detectedLanguage,
      plan,
      mcpActionExecuted: !!mcpResult,
      mcpResult: mcpResult || null,
      domain: "app.suitpax.com",
      capabilities: [
        "create_task",
        "update_task",
        "list_tasks",
        "create_travel_booking",
        "create_expense_report",
        "analyze_travel_data",
        "generate_travel_policy",
      ],
    })
  } catch (error) {
    console.error("Suitpax AI Error:", error)
    return NextResponse.json(
      {
        response: "Hey, I'm experiencing technical difficulties. Please try again in a moment!",
        error: "Technical issue",
      },
      { status: 500 },
    )
  }
}

// Enhanced MCP action detection and execution
async function detectAndExecuteMCPAction(message: string, userId: string, mcpClient: MCPClient) {
  const lowerMessage = message.toLowerCase()

  // Task Management Actions
  if (detectTaskCreation(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "create_task", extractTaskParams(message, userId))
  }

  if (detectTaskUpdate(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "update_task", extractTaskUpdateParams(message, userId))
  }

  if (detectTaskList(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "list_tasks", extractTaskListParams(message, userId))
  }

  // Travel Management Actions
  if (detectTravelBooking(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "create_travel_booking", extractTravelParams(message, userId))
  }

  if (detectExpenseReport(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "create_expense_report", extractExpenseReportParams(message, userId))
  }

  if (detectTravelAnalysis(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "analyze_travel_data", extractAnalysisParams(message, userId))
  }

  if (detectPolicyGeneration(lowerMessage)) {
    return await executeMCPFunction(mcpClient, "generate_travel_policy", extractPolicyParams(message, userId))
  }

  return null
}

// MCP Function Execution
async function executeMCPFunction(mcpClient: MCPClient, functionName: string, params: any) {
  try {
    const result = await mcpClient.callTool(functionName, params)
    return {
      function: functionName,
      params,
      result,
      success: true,
      timestamp: new Date().toISOString(),
    }
  } catch (error) {
    console.error(`MCP ${functionName} error:`, error)
    return {
      function: functionName,
      params,
      error: error.message,
      success: false,
      timestamp: new Date().toISOString(),
    }
  }
}

// Detection Functions
function detectTaskCreation(message: string): boolean {
  const triggers = [
    "create task",
    "add task",
    "new task",
    "task for",
    "remind me",
    "crear tarea",
    "a√±adir tarea",
    "nueva tarea",
    "ÂàõÂª∫‰ªªÂä°",
    "Ê∑ªÂä†‰ªªÂä°",
    "Êñ∞‰ªªÂä°",
    "criar tarefa",
    "adicionar tarefa",
    "nova tarefa",
    "—Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É",
    "–¥–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É",
    "–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞",
    "skapa uppgift",
    "l√§gg till uppgift",
    "ny uppgift",
    "cr√©er t√¢che",
    "ajouter t√¢che",
    "nouvelle t√¢che",
    "aufgabe erstellen",
    "aufgabe hinzuf√ºgen",
    "neue aufgabe",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectTaskUpdate(message: string): boolean {
  const triggers = [
    "complete task",
    "mark done",
    "update task",
    "finish task",
    "task completed",
    "completar tarea",
    "marcar hecho",
    "actualizar tarea",
    "ÂÆåÊàê‰ªªÂä°",
    "Êõ¥Êñ∞‰ªªÂä°",
    "‰ªªÂä°ÂÆåÊàê",
    "completar tarefa",
    "marcar feito",
    "atualizar tarefa",
    "–∑–∞–≤–µ—Ä—à–∏—Ç—å –∑–∞–¥–∞—á—É",
    "–æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á—É",
    "–∑–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞",
    "slutf√∂r uppgift",
    "uppdatera uppgift",
    "uppgift klar",
    "terminer t√¢che",
    "mettre √† jour t√¢che",
    "t√¢che termin√©e",
    "aufgabe abschlie√üen",
    "aufgabe aktualisieren",
    "aufgabe erledigt",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectTaskList(message: string): boolean {
  const triggers = [
    "show tasks",
    "list tasks",
    "my tasks",
    "pending tasks",
    "what tasks",
    "mostrar tareas",
    "listar tareas",
    "mis tareas",
    "tareas pendientes",
    "ÊòæÁ§∫‰ªªÂä°",
    "ÂàóÂá∫‰ªªÂä°",
    "ÊàëÁöÑ‰ªªÂä°",
    "ÂæÖÂäû‰ªªÂä°",
    "mostrar tarefas",
    "listar tarefas",
    "minhas tarefas",
    "tarefas pendentes",
    "–ø–æ–∫–∞–∑–∞—Ç—å –∑–∞–¥–∞—á–∏",
    "—Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á",
    "–º–æ–∏ –∑–∞–¥–∞—á–∏",
    "–æ–∂–∏–¥–∞—é—â–∏–µ –∑–∞–¥–∞—á–∏",
    "visa uppgifter",
    "lista uppgifter",
    "mina uppgifter",
    "v√§ntande uppgifter",
    "afficher t√¢ches",
    "lister t√¢ches",
    "mes t√¢ches",
    "t√¢ches en attente",
    "aufgaben anzeigen",
    "aufgaben auflisten",
    "meine aufgaben",
    "ausstehende aufgaben",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectTravelBooking(message: string): boolean {
  const triggers = [
    "book flight",
    "reserve hotel",
    "book travel",
    "need accommodation",
    "book room",
    "reservar vuelo",
    "reservar hotel",
    "reservar viaje",
    "necesito alojamiento",
    "È¢ÑËÆ¢Ëà™Áè≠",
    "È¢ÑËÆ¢ÈÖíÂ∫ó",
    "È¢ÑËÆ¢ÊóÖË°å",
    "ÈúÄË¶Å‰ΩèÂÆø",
    "reservar voo",
    "reservar hotel",
    "reservar viagem",
    "preciso acomoda√ß√£o",
    "–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–π—Å",
    "–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–µ–ª—å",
    "–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–µ–∑–¥–∫—É",
    "boka flyg",
    "boka hotell",
    "boka resa",
    "beh√∂ver boende",
    "r√©server vol",
    "r√©server h√¥tel",
    "r√©server voyage",
    "besoin h√©bergement",
    "flug buchen",
    "hotel buchen",
    "reise buchen",
    "unterkunft ben√∂tigt",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectExpenseReport(message: string): boolean {
  const triggers = [
    "expense report",
    "create report",
    "expense summary",
    "travel costs",
    "cost report",
    "reporte gastos",
    "crear reporte",
    "resumen gastos",
    "costos viaje",
    "Ë¥πÁî®Êä•Âëä",
    "ÂàõÂª∫Êä•Âëä",
    "Ë¥πÁî®ÊëòË¶Å",
    "ÊóÖË°åË¥πÁî®",
    "relat√≥rio despesas",
    "criar relat√≥rio",
    "resumo despesas",
    "custos viagem",
    "–æ—Ç—á–µ—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤",
    "—Å–æ–∑–¥–∞—Ç—å –æ—Ç—á–µ—Ç",
    "—Å–≤–æ–¥–∫–∞ —Ä–∞—Å—Ö–æ–¥–æ–≤",
    "—Ä–∞—Å—Ö–æ–¥—ã –ø–æ–µ–∑–¥–∫–∏",
    "kostnadsrapport",
    "skapa rapport",
    "kostnadssammanfattning",
    "resekostnader",
    "rapport d√©penses",
    "cr√©er rapport",
    "r√©sum√© d√©penses",
    "co√ªts voyage",
    "ausgabenbericht",
    "bericht erstellen",
    "ausgaben√ºbersicht",
    "reisekosten",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectTravelAnalysis(message: string): boolean {
  const triggers = [
    "analyze travel",
    "travel insights",
    "cost analysis",
    "travel trends",
    "travel data",
    "analizar viajes",
    "insights viajes",
    "an√°lisis costos",
    "tendencias viajes",
    "ÂàÜÊûêÊóÖË°å",
    "ÊóÖË°åÊ¥ûÂØü",
    "ÊàêÊú¨ÂàÜÊûê",
    "ÊóÖË°åË∂ãÂäø",
    "analisar viagens",
    "insights viagens",
    "an√°lise custos",
    "tend√™ncias viagens",
    "–∞–Ω–∞–ª–∏–∑ –ø–æ–µ–∑–¥–æ–∫",
    "–∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø–æ–µ–∑–¥–æ–∫",
    "–∞–Ω–∞–ª–∏–∑ –∑–∞—Ç—Ä–∞—Ç",
    "—Ç—Ä–µ–Ω–¥—ã –ø–æ–µ–∑–¥–æ–∫",
    "analysera resor",
    "reseinsikter",
    "kostnadsanalys",
    "resetrender",
    "analyser voyages",
    "insights voyages",
    "analyse co√ªts",
    "tendances voyages",
    "reisen analysieren",
    "reise-einblicke",
    "kostenanalyse",
    "reisetrends",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

function detectPolicyGeneration(message: string): boolean {
  const triggers = [
    "create policy",
    "travel policy",
    "expense policy",
    "travel guidelines",
    "policy rules",
    "crear pol√≠tica",
    "pol√≠tica viajes",
    "pol√≠tica gastos",
    "directrices viajes",
    "ÂàõÂª∫ÊîøÁ≠ñ",
    "ÊóÖË°åÊîøÁ≠ñ",
    "Ë¥πÁî®ÊîøÁ≠ñ",
    "ÊóÖË°åÊåáÂçó",
    "criar pol√≠tica",
    "pol√≠tica viagens",
    "pol√≠tica despesas",
    "diretrizes viagens",
    "—Å–æ–∑–¥–∞—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É",
    "–ø–æ–ª–∏—Ç–∏–∫–∞ –ø–æ–µ–∑–¥–æ–∫",
    "–ø–æ–ª–∏—Ç–∏–∫–∞ —Ä–∞—Å—Ö–æ–¥–æ–≤",
    "–ø—Ä–∞–≤–∏–ª–∞ –ø–æ–µ–∑–¥–æ–∫",
    "skapa policy",
    "resepolicy",
    "kostnadspolicy",
    "reseriktlinjer",
    "cr√©er politique",
    "politique voyage",
    "politique d√©penses",
    "directives voyage",
    "richtlinie erstellen",
    "reiserichtlinie",
    "ausgabenrichtlinie",
    "reiseregeln",
  ]
  return triggers.some((trigger) => message.includes(trigger))
}

// Parameter Extraction Functions
function extractTaskParams(message: string, userId: string) {
  return {
    user_id: userId,
    title: extractTaskTitle(message),
    description: message,
    priority: extractPriority(message),
    category: extractCategory(message),
    due_date: extractDueDate(message),
    assignee: extractAssignee(message),
  }
}

function extractTaskUpdateParams(message: string, userId: string) {
  return {
    user_id: userId,
    task_identifier: extractTaskIdentifier(message),
    status: extractTaskStatus(message),
    updates: extractTaskUpdates(message),
  }
}

function extractTaskListParams(message: string, userId: string) {
  return {
    user_id: userId,
    filters: {
      status: extractStatusFilter(message),
      priority: extractPriorityFilter(message),
      category: extractCategoryFilter(message),
      date_range: extractDateRangeFilter(message),
    },
  }
}

function extractTravelParams(message: string, userId: string) {
  return {
    user_id: userId,
    type: extractTravelType(message),
    destination: extractDestination(message),
    dates: extractTravelDates(message),
    preferences: extractTravelPreferences(message),
    budget: extractBudget(message),
    travelers: extractTravelers(message),
  }
}

function extractExpenseReportParams(message: string, userId: string) {
  return {
    user_id: userId,
    date_range: extractDateRange(message),
    categories: extractExpenseCategories(message),
    project: extractProject(message),
    format: extractReportFormat(message),
  }
}

function extractAnalysisParams(message: string, userId: string) {
  return {
    user_id: userId,
    analysis_type: extractAnalysisType(message),
    date_range: extractDateRange(message),
    metrics: extractMetrics(message),
    filters: extractAnalysisFilters(message),
  }
}

function extractPolicyParams(message: string, userId: string) {
  return {
    user_id: userId,
    policy_type: extractPolicyType(message),
    company_size: extractCompanySize(message),
    budget_limits: extractBudgetLimits(message),
    compliance_requirements: extractComplianceRequirements(message),
  }
}

// Language detection function (unchanged)
function detectLanguage(text: string): string {
  const languagePatterns = {
    Spanish: /\b(hola|crear|a√±adir|necesito|quiero|gracias|por favor)\b/i,
    Chinese: /[\u4e00-\u9fff]/,
    Portuguese: /\b(ol√°|criar|adicionar|preciso|quero|obrigado|por favor)\b/i,
    Russian: /[–∞-—è—ë]/i,
    Swedish: /\b(hej|skapa|l√§gga till|beh√∂ver|vill|tack|sn√§lla)\b/i,
    French: /\b(bonjour|cr√©er|ajouter|besoin|veux|merci|s'il vous pla√Æt)\b/i,
    German: /\b(hallo|erstellen|hinzuf√ºgen|brauche|m√∂chte|danke|bitte)\b/i,
  }

  for (const [language, pattern] of Object.entries(languagePatterns)) {
    if (pattern.test(text)) {
      return language
    }
  }

  return "English"
}

// Helper extraction functions (simplified implementations)
function extractTaskTitle(message: string): string {
  const patterns = [
    /(?:create task|add task|crear tarea|criar tarefa|ÂàõÂª∫‰ªªÂä°)(?:\s+(?:to|for|para|para|‰∏∫))?\s+(.+)/i,
    /(?:i need to|necesito|preciso|ÊàëÈúÄË¶Å|–º–Ω–µ –Ω—É–∂–Ω–æ)\s+(.+)/i,
  ]

  for (const pattern of patterns) {
    const match = message.match(pattern)
    if (match) return match[1].trim()
  }

  return message.length > 50 ? message.substring(0, 50) + "..." : message
}

function extractPriority(message: string): "low" | "medium" | "high" {
  const highPriority = /\b(urgent|high|importante|urgente|È´ò|—Å—Ä–æ—á–Ω–æ|br√•dskande|urgent|dringend)\b/i
  const lowPriority = /\b(low|bajo|baixo|‰Ωé|–Ω–∏–∑–∫–∏–π|l√•g|bas|niedrig)\b/i

  if (highPriority.test(message)) return "high"
  if (lowPriority.test(message)) return "low"
  return "medium"
}

function extractCategory(message: string): string {
  const travelKeywords = /\b(flight|hotel|travel|viaje|viagem|ÊóÖË°å|–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ|resa|voyage|reise)\b/i
  const expenseKeywords = /\b(expense|cost|gasto|despesa|Ë¥πÁî®|—Ä–∞—Å—Ö–æ–¥|kostnad|d√©pense|ausgabe)\b/i
  const meetingKeywords = /\b(meeting|reunion|reuni√£o|‰ºöËÆÆ|–≤—Å—Ç—Ä–µ—á–∞|m√∂te|r√©union|besprechung)\b/i

  if (travelKeywords.test(message)) return "travel"
  if (expenseKeywords.test(message)) return "expense"
  if (meetingKeywords.test(message)) return "meeting"
  return "general"
}

function extractDueDate(message: string): string {
  const datePatterns = [
    /\b(today|hoy|hoje|‰ªäÂ§©|—Å–µ–≥–æ–¥–Ω—è|idag|aujourd'hui|heute)\b/i,
    /\b(tomorrow|ma√±ana|amanh√£|ÊòéÂ§©|–∑–∞–≤—Ç—Ä–∞|imorgon|demain|morgen)\b/i,
    /\b(next week|pr√≥xima semana|pr√≥xima semana|‰∏ãÂë®|–Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π –Ω–µ–¥–µ–ª–µ|n√§sta vecka|semaine prochaine|n√§chste woche)\b/i,
  ]

  const now = new Date()

  if (datePatterns[0].test(message)) return now.toISOString().split("T")[0]
  if (datePatterns[1].test(message)) {
    const tomorrow = new Date(now)
    tomorrow.setDate(tomorrow.getDate() + 1)
    return tomorrow.toISOString().split("T")[0]
  }
  if (datePatterns[2].test(message)) {
    const nextWeek = new Date(now)
    nextWeek.setDate(nextWeek.getDate() + 7)
    return nextWeek.toISOString().split("T")[0]
  }

  // Default to 7 days from now
  const defaultDate = new Date(now)
  defaultDate.setDate(defaultDate.getDate() + 7)
  return defaultDate.toISOString().split("T")[0]
}

function extractAssignee(message: string): string | null {
  const assigneePattern =
    /\b(?:assign to|asignar a|atribuir a|ÂàÜÈÖçÁªô|–Ω–∞–∑–Ω–∞—á–∏—Ç—å|tilldela|assigner √†|zuweisen an)\s+([a-zA-Z\s]+)/i
  const match = message.match(assigneePattern)
  return match ? match[1].trim() : null
}

function extractTaskIdentifier(message: string): string {
  const idPattern = /\b(?:task|tarea|tarefa|‰ªªÂä°|–∑–∞–¥–∞—á–∞|uppgift|t√¢che|aufgabe)\s+(?:#)?(\w+)/i
  const match = message.match(idPattern)
  return match ? match[1] : ""
}

function extractTaskStatus(message: string): string {
  if (/\b(complete|done|finished|completado|hecho|terminado|ÂÆåÊàê|–∑–∞–≤–µ—Ä—à–µ–Ω–æ|klar|termin√©|fertig)\b/i.test(message)) {
    return "completed"
  }
  if (/\b(in progress|en progreso|em andamento|ËøõË°å‰∏≠|–≤ –ø—Ä–æ—Ü–µ—Å—Å–µ|p√•g√•r|en cours|in bearbeitung)\b/i.test(message)) {
    return "in_progress"
  }
  return "pending"
}

function extractTaskUpdates(message: string): any {
  return {
    notes: message,
    updated_at: new Date().toISOString(),
  }
}

function extractStatusFilter(message: string): string | null {
  if (/\b(pending|pendiente|pendente|ÂæÖÂäû|–æ–∂–∏–¥–∞—é—â–∏–µ|v√§ntande|en attente|ausstehend)\b/i.test(message)) return "pending"
  if (/\b(completed|completado|completado|Â∑≤ÂÆåÊàê|–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ|slutf√∂rda|termin√©es|abgeschlossen)\b/i.test(message))
    return "completed"
  if (/\b(in progress|en progreso|em andamento|ËøõË°å‰∏≠|–≤ –ø—Ä–æ—Ü–µ—Å—Å–µ|p√•g√•ende|en cours|in bearbeitung)\b/i.test(message))
    return "in_progress"
  return null
}

function extractPriorityFilter(message: string): string | null {
  if (/\b(high|alto|alto|È´ò|–≤—ã—Å–æ–∫–∏–π|h√∂g|√©lev√©|hoch)\b/i.test(message)) return "high"
  if (/\b(low|bajo|baixo|‰Ωé|–Ω–∏–∑–∫–∏–π|l√•g|bas|niedrig)\b/i.test(message)) return "low"
  if (/\b(medium|medio|m√©dio|‰∏≠|—Å—Ä–µ–¥–Ω–∏–π|medel|moyen|mittel)\b/i.test(message)) return "medium"
  return null
}

function extractCategoryFilter(message: string): string | null {
  if (/\b(travel|viaje|viagem|ÊóÖË°å|–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ|resa|voyage|reise)\b/i.test(message)) return "travel"
  if (/\b(expense|gasto|despesa|Ë¥πÁî®|—Ä–∞—Å—Ö–æ–¥|kostnad|d√©pense|ausgabe)\b/i.test(message)) return "expense"
  if (/\b(meeting|reuni√≥n|reuni√£o|‰ºöËÆÆ|–≤—Å—Ç—Ä–µ—á–∞|m√∂te|r√©union|besprechung)\b/i.test(message)) return "meeting"
  return null
}

function extractDateRangeFilter(message: string): any {
  const now = new Date()

  if (
    /\b(this week|esta semana|esta semana|Êú¨Âë®|–Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ|denna vecka|cette semaine|diese woche)\b/i.test(message)
  ) {
    const startOfWeek = new Date(now)
    startOfWeek.setDate(now.getDate() - now.getDay())
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(startOfWeek.getDate() + 6)
    return { start: startOfWeek.toISOString().split("T")[0], end: endOfWeek.toISOString().split("T")[0] }
  }

  if (/\b(this month|este mes|este m√™s|Êú¨Êúà|–≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ|denna m√•nad|ce mois|diesen monat)\b/i.test(message)) {
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)
    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0)
    return { start: startOfMonth.toISOString().split("T")[0], end: endOfMonth.toISOString().split("T")[0] }
  }

  return null
}

function extractTravelType(message: string): string {
  if (/\b(flight|vuelo|voo|Ëà™Áè≠|—Ä–µ–π—Å|flyg|vol|flug)\b/i.test(message)) return "flight"
  if (/\b(hotel|hotel|hotel|ÈÖíÂ∫ó|–æ—Ç–µ–ª—å|hotell|h√¥tel|hotel)\b/i.test(message)) return "hotel"
  if (/\b(car|coche|carro|Ê±ΩËΩ¶|–º–∞—à–∏–Ω–∞|bil|voiture|auto)\b/i.test(message)) return "car"
  if (/\b(train|tren|trem|ÁÅ´ËΩ¶|–ø–æ–µ–∑–¥|t√•g|train|zug)\b/i.test(message)) return "train"
  return "general"
}

function extractDestination(message: string): string {
  const destinationPattern = /\b(?:to|a|para|Âéª|–≤|till|√†|nach)\s+([A-Za-z\s]+?)(?:\s|$|,|\.|!|\?)/i
  const match = message.match(destinationPattern)
  return match ? match[1].trim() : ""
}

function extractTravelDates(message: string): any {
  const now = new Date()

  if (
    /\b(next week|pr√≥xima semana|pr√≥xima semana|‰∏ãÂë®|–Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π –Ω–µ–¥–µ–ª–µ|n√§sta vecka|semaine prochaine|n√§chste woche)\b/i.test(
      message,
    )
  ) {
    const nextWeek = new Date(now)
    nextWeek.setDate(now.getDate() + 7)
    return { departure: nextWeek.toISOString().split("T")[0] }
  }

  if (
    /\b(next month|pr√≥ximo mes|pr√≥ximo m√™s|‰∏ã‰∏™Êúà|–≤ —Å–ª–µ–¥—É—é—â–µ–º –º–µ—Å—è—Ü–µ|n√§sta m√•nad|mois prochain|n√§chsten monat)\b/i.test(
      message,
    )
  ) {
    const nextMonth = new Date(now)
    nextMonth.setMonth(now.getMonth() + 1)
    return { departure: nextMonth.toISOString().split("T")[0] }
  }

  return { departure: new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString().split("T")[0] }
}

function extractTravelPreferences(message: string): any {
  const preferences: any = {}

  if (
    /\b(business class|clase ejecutiva|classe executiva|ÂïÜÂä°Ëà±|–±–∏–∑–Ω–µ—Å –∫–ª–∞—Å—Å|business klass|classe affaires|business class)\b/i.test(
      message,
    )
  ) {
    preferences.class = "business"
  }
  if (/\b(economy|econ√≥mica|econ√¥mica|ÁªèÊµéËà±|—ç–∫–æ–Ω–æ–º|ekonomi|√©conomique|economy)\b/i.test(message)) {
    preferences.class = "economy"
  }
  if (/\b(non-stop|directo|direto|Áõ¥È£û|–ø—Ä—è–º–æ–π|direktflyg|direct|direktflug)\b/i.test(message)) {
    preferences.stops = "non-stop"
  }

  return preferences
}

function extractBudget(message: string): number | null {
  const budgetPattern = /(?:‚Ç¨|EUR|euro|euros?)\s*(\d+(?:\.\d{2})?)|(\d+(?:\.\d{2})?)\s*(?:‚Ç¨|EUR|euro|euros?)/i
  const match = message.match(budgetPattern)
  return match ? Number.parseFloat(match[1] || match[2]) : null
}

function extractTravelers(message: string): number {
  const travelersPattern = /\b(\d+)\s*(?:people|person|personas|pessoas|‰∫∫|—á–µ–ª–æ–≤–µ–∫|personer|personnes|personen)\b/i
  const match = message.match(travelersPattern)
  return match ? Number.parseInt(match[1]) : 1
}

function extractDateRange(message: string): any {
  const now = new Date()

  if (
    /\b(last month|mes pasado|m√™s passado|‰∏ä‰∏™Êúà|–ø—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü|f√∂rra m√•naden|mois dernier|letzten monat)\b/i.test(
      message,
    )
  ) {
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1)
    const endLastMonth = new Date(now.getFullYear(), now.getMonth(), 0)
    return { start: lastMonth.toISOString().split("T")[0], end: endLastMonth.toISOString().split("T")[0] }
  }

  if (
    /\b(this quarter|este trimestre|este trimestre|Êú¨Â≠£Â∫¶|—ç—Ç–æ—Ç –∫–≤–∞—Ä—Ç–∞–ª|detta kvartal|ce trimestre|dieses quartal)\b/i.test(
      message,
    )
  ) {
    const quarter = Math.floor(now.getMonth() / 3)
    const startQuarter = new Date(now.getFullYear(), quarter * 3, 1)
    const endQuarter = new Date(now.getFullYear(), (quarter + 1) * 3, 0)
    return { start: startQuarter.toISOString().split("T")[0], end: endQuarter.toISOString().split("T")[0] }
  }

  // Default to last 30 days
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
  return { start: thirtyDaysAgo.toISOString().split("T")[0], end: now.toISOString().split("T")[0] }
}

function extractExpenseCategories(message: string): string[] {
  const categories = []

  if (/\b(food|comida|comida|È£üÁâ©|–µ–¥–∞|mat|nourriture|essen)\b/i.test(message)) categories.push("food")
  if (/\b(transport|transporte|transporte|‰∫§ÈÄö|—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç|transport|transport|transport)\b/i.test(message))
    categories.push("transport")
  if (/\b(accommodation|alojamiento|acomoda√ß√£o|‰ΩèÂÆø|—Ä–∞–∑–º–µ—â–µ–Ω–∏–µ|boende|h√©bergement|unterkunft)\b/i.test(message))
    categories.push("accommodation")
  if (
    /\b(entertainment|entretenimiento|entretenimento|Â®±‰πê|—Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è|underh√•llning|divertissement|unterhaltung)\b/i.test(
      message,
    )
  )
    categories.push("entertainment")

  return categories.length > 0 ? categories : ["all"]
}

function extractProject(message: string): string | null {
  const projectPattern = /\b(?:project|proyecto|projeto|È°πÁõÆ|–ø—Ä–æ–µ–∫—Ç|projekt|projet|projekt)\s+([a-zA-Z0-9\s]+)/i
  const match = message.match(projectPattern)
  return match ? match[1].trim() : null
}

function extractReportFormat(message: string): string {
  if (/\b(pdf|PDF)\b/.test(message)) return "pdf"
  if (/\b(excel|xlsx|XLSX)\b/.test(message)) return "excel"
  if (/\b(csv|CSV)\b/.test(message)) return "csv"
  return "pdf"
}

function extractAnalysisType(message: string): string {
  if (/\b(cost|costo|custo|ÊàêÊú¨|—Å—Ç–æ–∏–º–æ—Å—Ç—å|kostnad|co√ªt|kosten)\b/i.test(message)) return "cost_analysis"
  if (/\b(trend|tendencia|tend√™ncia|Ë∂ãÂäø|—Ç—Ä–µ–Ω–¥|trend|tendance|trend)\b/i.test(message)) return "trend_analysis"
  if (/\b(pattern|patr√≥n|padr√£o|Ê®°Âºè|—à–∞–±–ª–æ–Ω|m√∂nster|mod√®le|muster)\b/i.test(message)) return "pattern_analysis"
  if (/\b(compliance|cumplimiento|conformidade|ÂêàËßÑ|—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ|efterlevnad|conformit√©|compliance)\b/i.test(message))
    return "compliance_analysis"
  return "general_analysis"
}

function extractMetrics(message: string): string[] {
  const metrics = []

  if (/\b(cost|costo|custo|ÊàêÊú¨|—Å—Ç–æ–∏–º–æ—Å—Ç—å|kostnad|co√ªt|kosten)\b/i.test(message)) metrics.push("cost")
  if (/\b(frequency|frecuencia|frequ√™ncia|È¢ëÁéá|—á–∞—Å—Ç–æ—Ç–∞|frekvens|fr√©quence|h√§ufigkeit)\b/i.test(message))
    metrics.push("frequency")
  if (/\b(duration|duraci√≥n|dura√ß√£o|ÊåÅÁª≠Êó∂Èó¥|–ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å|varaktighet|dur√©e|dauer)\b/i.test(message))
    metrics.push("duration")
  if (/\b(efficiency|eficiencia|efici√™ncia|ÊïàÁéá|—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å|effektivitet|efficacit√©|effizienz)\b/i.test(message))
    metrics.push("efficiency")

  return metrics.length > 0 ? metrics : ["cost", "frequency"]
}

function extractAnalysisFilters(message: string): any {
  return {
    department: extractDepartment(message),
    employee: extractEmployee(message),
    destination: extractDestination(message),
    travel_type: extractTravelType(message),
  }
}

function extractDepartment(message: string): string | null {
  const deptPattern =
    /\b(?:department|departamento|departamento|ÈÉ®Èó®|–æ—Ç–¥–µ–ª|avdelning|d√©partement|abteilung)\s+([a-zA-Z\s]+)/i
  const match = message.match(deptPattern)
  return match ? match[1].trim() : null
}

function extractEmployee(message: string): string | null {
  const empPattern = /\b(?:employee|empleado|funcion√°rio|ÂëòÂ∑•|—Å–æ—Ç—Ä—É–¥–Ω–∏–∫|anst√§lld|employ√©|mitarbeiter)\s+([a-zA-Z\s]+)/i
  const match = message.match(empPattern)
  return match ? match[1].trim() : null
}

function extractPolicyType(message: string): string {
  if (/\b(expense|gasto|despesa|Ë¥πÁî®|—Ä–∞—Å—Ö–æ–¥|kostnad|d√©pense|ausgabe)\b/i.test(message)) return "expense_policy"
  if (/\b(travel|viaje|viagem|ÊóÖË°å|–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ|resa|voyage|reise)\b/i.test(message)) return "travel_policy"
  if (/\b(approval|aprobaci√≥n|aprova√ß√£o|ÊâπÂáÜ|–æ–¥–æ–±—Ä–µ–Ω–∏–µ|godk√§nnande|approbation|genehmigung)\b/i.test(message))
    return "approval_policy"
  return "general_policy"
}

function extractCompanySize(message: string): string {
  if (/\b(startup|peque√±a|pequena|ÂàùÂàõ|—Å—Ç–∞—Ä—Ç–∞–ø|startup|startup|startup)\b/i.test(message)) return "startup"
  if (/\b(small|peque√±a|pequena|Â∞è|–º–∞–ª—ã–π|liten|petite|klein)\b/i.test(message)) return "small"
  if (/\b(medium|mediana|m√©dia|‰∏≠|—Å—Ä–µ–¥–Ω–∏–π|medel|moyenne|mittel)\b/i.test(message)) return "medium"
  if (/\b(large|grande|grande|Â§ß|–±–æ–ª—å—à–æ–π|stor|grande|gro√ü)\b/i.test(message)) return "large"
  if (/\b(enterprise|empresa|empresa|‰ºÅ‰∏ö|–ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ|f√∂retag|entreprise|unternehmen)\b/i.test(message))
    return "enterprise"
  return "medium"
}

function extractBudgetLimits(message: string): any {
  const limits: any = {}

  const dailyPattern =
    /(?:daily|diario|di√°rio|ÊØèÊó•|–µ–∂–µ–¥–Ω–µ–≤–Ω–æ|daglig|quotidien|t√§glich)\s*(?:‚Ç¨|EUR|euro|euros?)\s*(\d+)/i
  const monthlyPattern =
    /(?:monthly|mensual|mensal|ÊØèÊúà|–µ–∂–µ–º–µ—Å—è—á–Ω–æ|m√•nadsvis|mensuel|monatlich)\s*(?:‚Ç¨|EUR|euro|euros?)\s*(\d+)/i

  const dailyMatch = message.match(dailyPattern)
  const monthlyMatch = message.match(monthlyPattern)

  if (dailyMatch) limits.daily = Number.parseInt(dailyMatch[1])
  if (monthlyMatch) limits.monthly = Number.parseInt(monthlyMatch[1])

  return limits
}

function extractComplianceRequirements(message: string): string[] {
  const requirements = []

  if (/\b(receipt|recibo|recibo|Êî∂ÊçÆ|—á–µ–∫|kvitto|re√ßu|beleg)\b/i.test(message)) requirements.push("receipt_required")
  if (/\b(approval|aprobaci√≥n|aprova√ß√£o|ÊâπÂáÜ|–æ–¥–æ–±—Ä–µ–Ω–∏–µ|godk√§nnande|approbation|genehmigung)\b/i.test(message))
    requirements.push("approval_required")
  if (
    /\b(justification|justificaci√≥n|justificativa|ÁêÜÁî±|–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ|motivering|justification|begr√ºndung)\b/i.test(
      message,
    )
  )
    requirements.push("justification_required")

  return requirements.length > 0 ? requirements : ["receipt_required"]
}
